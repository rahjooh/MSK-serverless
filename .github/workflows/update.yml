name: Update

on:
  workflow_dispatch:

permissions:
  contents: read

env:
  TERRAFORM_VERSION: 1.6.6
  TF_VARS_FILE: ci.auto.tfvars
  TF_BACKEND_FILE: backend.auto.tfbackend
  AWS_REGION: ${{ vars.AWS_REGION || '' }}
  TF_BACKEND_BUCKET: ${{ vars.TF_BACKEND_BUCKET || vars.S3_BUCKET || '' }}
  TF_BACKEND_REGION: ${{ vars.TF_BACKEND_REGION || vars.AWS_REGION || '' }}
  TF_BACKEND_KEY: ${{ vars.TF_BACKEND_KEY || '' }}
  S3_BUCKET: ${{ vars.S3_BUCKET || '' }}

jobs:
  update:
    name: Import existing AWS resources into Terraform state
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Load Terraform configuration
        run: python3 scripts/load_terraform_config.py
        env:
          TERRAFORM_TFVARS: ${{ secrets.TERRAFORM_TFVARS }}

      - name: Mask sensitive values
        run: |
          set -euo pipefail
          mask() { local v="${!1:-}"; if [ -n "$v" ]; then echo "::add-mask::$v"; fi; }
          for var in \
            AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN \
            ASSUME_ROLE_ARN AWS_ASSUME_ROLE_ARN \
            TF_VAR_vpc_id TF_VAR_subnet_ids \
            TF_BACKEND_BUCKET TF_BACKEND_KEY S3_BUCKET; do
            mask "$var" || true
          done

      - name: Ensure AWS access keys are provided
        run: |
          set -euo pipefail
          missing=0
          for var in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY; do
            if [ -z "${!var:-}" ]; then
              echo "::error::Missing $var secret. Add it to the repository or environment secrets.";
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Validate backend config (skip invalid)
        if: ${{ hashFiles(env.TF_BACKEND_FILE) != '' }}
        run: |
          set -euo pipefail
          FILE="${TF_BACKEND_FILE}"
          if ! grep -Eq '^[[:space:]]*(bucket|key)[[:space:]]*=' "$FILE"; then
            echo "::notice::Invalid backend config in $FILE; removing so init can use default/backend args."
            rm -f "$FILE"
          fi

      - name: Read backend from versions.tf (fallback)
        if: ${{ hashFiles(env.TF_BACKEND_FILE) == '' }}
        run: |
          python3 - <<'PY'
          import os, re, sys
          path = 'versions.tf'
          if not os.path.isfile(path):
              sys.exit(0)
          content = open(path, 'r', encoding='utf-8').read()
          m = re.search(r'backend\s+"s3"\s*\{', content)
          if not m:
              sys.exit(0)
          i = m.end()
          depth = 1
          kv = {}
          while i < len(content) and depth > 0:
              ch = content[i]
              if ch == '{':
                  depth += 1
              elif ch == '}':
                  depth -= 1
              i += 1
              if depth == 0:
                  break
          block = content[m.end():i-1]
          for raw in block.splitlines():
              line = raw.split('#',1)[0].strip()
              if not line or '=' not in line:
                  continue
              k, v = line.split('=', 1)
              k = k.strip()
              v = v.strip().strip('"')
              if k in {'bucket','key','region'}:
                  kv[k] = v
          env_path = os.environ.get('GITHUB_ENV')
          if env_path:
              with open(env_path, 'a', encoding='utf-8') as fh:
                  if 'bucket' in kv:
                      fh.write(f"TF_BACKEND_BUCKET={kv['bucket']}\n")
                  if 'key' in kv:
                      fh.write(f"TF_BACKEND_KEY={kv['key']}\n")
                  if 'region' in kv:
                      fh.write(f"TF_BACKEND_REGION={kv['region']}\n")
          PY

      - name: Avoid double assume (clear TF_VAR_assume_role_arn when GH already assumed)
        if: ${{ env.ASSUME_ROLE_ARN != '' }}
        run: |
          {
            echo "TF_VAR_assume_role_arn<<EOF";
            echo "";
            echo "EOF";
          } >> "$GITHUB_ENV"

      - name: Show Terraform version
        run: terraform version

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.TF_BACKEND_REGION || env.AWS_REGION_EFFECTIVE || env.AWS_REGION || secrets.AWS_REGION }}
          role-to-assume: ${{ env.ASSUME_ROLE_ARN || '' }}
          role-duration-seconds: ${{ env.ASSUME_ROLE_ARN != '' && '3600' || '' }}
          role-skip-session-tagging: true

      - name: Preflight AWS identity
        run: |
          echo "Region: ${AWS_REGION_EFFECTIVE:-$AWS_REGION}"
          aws sts get-caller-identity

      - name: Update remote Terraform state
        run: bash scripts/rebuild-tfstate.sh
        env:
          # Prevent provider-level re-assume during CI state rebuild, but only for
          # commands that accept -var (avoid breaking init/import)
          TF_CLI_ARGS_apply: -var=assume_role_arn=""
          TF_CLI_ARGS_plan: -var=assume_role_arn=""
          STATE_DEBUG: 1
